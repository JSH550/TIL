### 데이터 동시 접근의 문제
1. 동일 데이터에 다수 사용자의 접근 허용 시 일관성의 훼손

# 트랜잭션
## 트랜잭션의 개념
- 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 연산의 집합
   - 예: 에금 인출
   - 작업단위 : 예금 1000원 인출
   - 일련의 연산 : Read(A), A=A-1000, Write(A)
- 데이터베이스를 사용하여 처리하는 작업을 하나의 묶음으로 인식하여 묶음 단위로 실행되도록 정의한 개념
- 데이터 베이스의 일관성,무결성,신뢰성 유지를 위해 사용한다.
## 트랜젝션의 특징(ACID 특성)
1. 다수의 연산으로 구성된 트랜잭션이 사용자에게 단일작업처럼 다루지도록 ACID 특징을 준수
### Atomicity(원자성)
- 하나의 트랜잭션에 포함된 모든 연산은 완전히 수행되거나 전혀 수행되지 않는다.(All or Nothing)
### Consistency(일관성)
- 특정 트랜잭션이 수행되기 전과 후에 데이터베이스가 일관된 상태를 유지
### Isolation(고립성)
- 특정 트랜잭션이 데이터베이스를 갱신하는 동안 다른 트랜잭션에 의해 방해받지 말아야 한다.
- 각 트랜잭션은 독립적으로 실행한 것 처럼 동작해야 한다.
### Durability(지속성)
- 완료된(커밋된) 트랜잭션의 결과는 어떠한 시스템의 장애에도 데이터베이스에 영구적으로 반영되어야 한다.

## 트랜잭션
### Read(X)
- 데이터 베이스에서 데이터 X를 읽고, 트랜잭션이 실행되는 메모리의 변수 X에 값을 저장하는 연산
### Write(X)
- 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장하는 연산

```
계좌 A에서 B로 1000원을 이체하는 트랜잭션

Read(A)
A := A-1000
    Write(A)
    Read(B)
B := B+1000
    Write(B)

원자성 : 트랜잭션 처리 도중 문제 발생시 수행 결과를 Roll back

일관성 : A B 계좌에 각각 10000원이 있었을때, 트랜잭션이 끝난 이후에 최종적으로 전체 계좌의 잔액은 20000이 된다.

고립성 : 트랜잭션이 처리되는 도중에 다른 트랜잭션(예를들어 A계좌의 값을 읽는 트랜잭션)에 의해 방해받지 않는다.

지속성 : 트랜잭션 결과는 DB에 반영되어야 한다. A계좌 : 9000 B 계좌 : 11000

```


### Commit
- 트랜잭션을 성공적으로 완료했고 결과가 일관성을 유지할때, 모든 변경사항을 데이터베이스에 영구적을 반영한다.

### Rollback
- 트랜잭션 도중 문제 발생시(aborted),  트랜잭션을 중단하고 모든 변경사항을 트랜잭션 시작 전으로 되돌린다.(원자성 유지)


## 트랜잭션의 상태
![alt text](이미지/트랜잭션상태.png)

1. 동작(Active) : 트랜잭션이 시작을 준비 또는 실행중인 상태
2. 부분커밋(Partially Committed) : 마지막 연산을 실행한 직후의 상태 데이터가 갱신된 데이터가 메모리에만 존재한다.
3. 커밋(Committed) : 모든 실행이 성공적으로 완료되어 DB에 영구적으로 반영된 상태
4. 실패(Failed) : 트랜잭션 실행 도중 에러가 발생한 상태. 트랜잭션 시작 이전으로 DB를 롤백시킨다.
5. 중단(Aborted) : 트랜잭션 시작하기 전 상태로 환원되고 트랜잭션이 종료된 상태.

# 트랜잭션의 동시성 제어(Concurrency Control)
## 동시성 제어 개념
- DBMS에서 여러 트랜잭션이 동시 실행될때 데이터의 일관성 무결성을 보장하기 위한 메커니즘
## 동시성의 필요성
- DBMS는 다수의 사용자가 동시에 사용
- 트랜잭션 대기시간(wait time) 감소
- 트랜잭션 처리율, 이용률 향상
## 동시성의 문제점
### 갱신손실 (Lost Update)
- 두개 이상의 트랜잭션이 동일한 데이터를 수정하려 할때, 데이터 수정 결과가 덮어 쓰여질 수 있는 문제

### 비반복적 읽기(Non-repeatble Read)
- 한 트랜잭션이 같은 데이터를 두번 이상 읽을때 그 사이 다른 트랜잭션에 의해 데이터가 변경되면 다른 값을 읽게되는 문제
### 팬텀 리드(Phantom Read)
- 한 트랜잭션이 범위의 데이터를 읽을때, 다른 트랜잭션에 의해 데이터가 수정되는 문제
### 더티 리드(Drity Read)
- 한 트랜잭션이 아직 커밋되지 않은 데이터를 읽는 문제

## 동시성 적용 트랜잭션
1. A와 B에 각각  10000, 20000 잔액이 있다
2. T : 1000원을 계좌 A에서 B로 이체
3. T : 계좌 A의 잔고에서 20%를 B로 이체
- 스케줄
  - 다수의 트랜잭션에 포함된 연산의 실행 순서를 명시한 것

## 직렬 스케줄
- 각 트랜잭션에 속한 모든 연산이 순차적으로 실행되는 스케줄
![alt text](image-28.png)

## 병렬 스케줄
- 하나의 트랜잭션이 완료되기 전에 달느 트랜잭션이 실행되는 스케줄
- 병렬스케줄의 순서로 연산을 수행할 경우 일관성의 훼손이 발생 가능


## 직렬 가능 스케줄(Serializable Schedule)
- 여러 트랜잭션이 병렬로 실행되더라도, 그 결과가 직렬 스케쥴과 동일한 경우를 직렬가능 스케쥴이라 한다.
- 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직력 스케줄과 동등하게 변환이 가능한 스케줄
### 충돌(conflict)
- 서로다른 트랜잭션이 Ti에 대해 연산할때, write 연산이 포함된 경우 충돌한다고 한다.
- 이때 write 순서가 바뀜에 따라 트랜잭션 결과가 바뀔수 있어 연산 교환이 불가능하다.

### 충돌 동등(Conflict Equivalent)
- 특정 트랜잭션 스케줄 S에서 충돌하지 않는 선에서 연산 순서를 바꾼 스케줄 S'로 변환이 가능한 상태를 충돌동등 이라고 한다.

```
교환전

Read B
        Write A


교환후
        Write A
Read B

교환 전후의 결과가 같다 => 충돌동등

```

### 충돌 직렬성(Conflict Serializable)
- 충돌 동등에서 확장된 개념
- 순서 교환이 가능한 연산을 교환하여 직렬 스케줄의 연산과 동등하게 변환이 가능한 스케줄
- 순서 교환 전

|T3|T4|
|:--:|:--:|
|Read A||
|Write A||
||Read A|
||Write A|
|Read B||
|Write B||
||Read B|
||Write B|

- 순서 교환 후
- 
|T3|T4|
|:--:|:--:|
|Read A||
|Write A||
|Read B| |
|Write B| |
| |Read A|
| |Write A|
||Read B |
||Write B|

# 트랜잭션의 회복화
## 회복의 개념
1. 원자성을 보장하기 위해 트랜잭션 실패 시 실행된 모든 연산을 실행 이전 상태로 복원하는 방법
2. 회복 불가 스케줄
- T4가 기록한 A를 읽고 커밋한 상태, 커밋한 트랜잭션은 롤백 불가능

|T3|T4|
|:--:|:--:|
|Read A||
|Write A||
||Read A|
||Coomit|
|Read B||//문제발생 롤백시행

## 회복 가능한 스케줄(Recoverable Schedule)
- Ti와 Tj에 대해 Ti가 기록한 데이터를 Tj가 읽을때, Ti의 커밋이 Tj 보다 먼저 나타나는 스케줄
- 즉, 트랜잭션 Ti가 데이터를 읽을때, 해당 데이터는 다른 트랜잭션에서 Write 연산이 종료된 후 커밋된 상태여야 한다.
-  
- 연쇄적 롤백 유발 가능
- T1의 롤백으로 인해, 연쇄적으로 다른 트랜잭션도 롤백되는 현상
  
#### 스케줄 A
|T1|T2|T3|
|:--:|:--:|:--:|
|Read A|||
|Write A|||
||Read A||
||Write A||
|||Read A|
|Abort|||

### 비연쇄적 스케줄
1. 연쇄적 롤백으로 발생할 수 있는 대량의 회복 연산을 방지하기 위해, 연쇄적이지 않은 스케줄로 구성된 스케줄
2. Ti가 기록한 데이털를 읽을때 Ti의 커밋이 Tj의 읽기 연산보다 먼저 나타나는 스케줄

#### 수정된 스케줄 A

|T1|T2|T3|
|:--:|:--:|:--:|
|Read A|||
|Write A|||
|Commit|||
||Read A||
||Write A||
||Commit||
|||Read A|

## 회복 불가능한 스케쥴(Irrecoverable Schedule)
- 트랜잭션이 데이터에 Read 연산을 진행하였을때, 해당 데이터를 Write한 트랜잭션이 커밋되지 않은 경울 회복 불가능한 스케쥴이라 한다.
