# 교착상태
## 프로세스의 자원 사용 절차
- 요구 ->획득-> 사용-> 해제 순으로 진행
- 요구 과정에서 가용한 자원이 없으면 자원을 획득할때까지 대기
### 자원
- 하드웨어 자원 또는 소프트웨어 자원
- I/O device, CPU cycle, memory space, semaphore 등
## 교착상태(deadlock) 정의
- 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 `영원히` 진행하지 못하는 상태
- `기아상태`는 언젠가는 해소 될 가능성이 있지만, 교착상태는 해소될 가능성이 없는 상태다
### 자원
- 하드웨어 소프트웨어 등을 포함하는 개념
- I/O device, CPU cycle, memory space, semaphore 등
```
프로세스 1

자원 1 사용 중
자원 2 요구

프로세스 2
자원 2 사용 중
자원 1 요구


자원 1,2 는 프로세스 1,2에 의해 사용 중으로 프로세스가 요청하더라도 사용할 수 없음

결국 프로세스 1,2는 영원히 대기상태에 빠지게 된다(교착상태)
```

## 교착상태의 필요조건
- 교착상태가 발생하려면 4가지의 필요조건이 필요하다
- 필요조건이기 때문에 반드시 교착상태가 생기는것은 아니다.

### 1. 상호배제 조건(mutual exclusion)
- 프로세스가 자원에 대한 배타적인 통제권을 요구(매순간 `하나의 프로세스`만 자원을 사용할 수 있음)
- `적어도 하나 이상`의 자원은 여러 프로세스에 의해 동시에 사용될 수 없음(모든 자원이 동시에 사용가능하면 상호배제가 아님)
- 다른 프로세스가 점유한 자원이 필요하면 반드시 대기


### 2. 점유대기 조건(hold and wait)
- 프로세스가 `이미 한 자원을 할당받아 점유`하고 있는 상황에서 `다른 프로세스가 점유하고 있는 또 다른 자원`을 요구하여 해제되기를 기다리는 상황
  

### 3. 비선점 조건(no preemption)
- 프로세스가 할당된 자원은 그 프로세스가 `스스로 반환하기 전`에는 해제되지 않음
- 할당된 자원은 `타의`에 의해서는 해제되지 않음

### 4. 환형대기 조건(circular wait)
- 프로세스의 자원점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황

## 자원할당 그래프 G=(V,E)
- V(Vertex): 정점의 집합 V=P∪R
  - P={P1,P2...Pn}: n개의 프로세스
  - R={r1,r2..rm}m개의 자원
- E(Edge): 방향 있는 간선의 집합 E=Q∪S
  - Q: {(pi,rj):pi∈P, rj∈R}:프로세스 pi가 자원 rj를 요구
  - 요구간선 pi -> rj
- S: {(rj,pi):rj∈R,pi∈P}:자원 rj가 프로세스 pi에 할당
  - 할당간선 rj->pi

### 자원 할당 그래프에서의 교착상태 필요조건
1. 상호배제: 하나의 단위자원당 하나의 할당간선으로 표현한다
2. 점유대기: 한 프로세스에 할당간선과 요구간선 연결(점유와 요구를 동시에 한 상태)
3. 비선점: 요구간선(요구한채로 대기)
4. 환형대기: 사이클
- 사이클이 없으면
  -  데드락 상태가 아니다
- 사이클이 있으면
  - `자원에 인스턴스가 하나`면 데드락 상태다.
  - `자원에 인스턴스가 여러개` 일경우 데드락일 가능성이 있는 상태다.
  


![alt text](/Computer%20Science/운영체제/이미지/교착상태.png)


![alt text](/Computer%20Science/운영체제/이미지/교착상태가아닌사이클.png)

# 교착상태의 처리기법
## 교착상태의 예방(Deadlock Prevention)
- 교착상태의 네가지 필요조건이 동시에 만족되는 것을 피하여, 교착상태가 발생되지 않도록 하는 방법
- 제약 조건이 많아질수록 오버헤드가 커져 비효율적인 시스템이 된다.(데드락이 생기지 않으면 자원 낭비)

### 상호 배제 조건 제거 (Mutual Exclusion)
- 공유할 수 있는 자원의 경우
  - 상호배제가 필요 없다.
  - 예: 읽기 전용 파일
- 공유할수 없는 자원 : 반드시 상호배제 필요
  - 예: 프린터
- 상호배제 조건이 필요한 자원은 두가지 이상의 프로세스가 점유할경우 문제가 생기는 경우다, `상호 배제 조건은 제거할수 없다.`


### 점유 대기 조건 제거(Hold and Wait)
1. 자원을 점유했을때 대기하지 않아야함
    - 프로세스가 앞으로 필요한 모든 자원을 처음에 `한꺼번에 요구하여 할당받음`
    - 자원이용률 낮아짐,`다른 프로세스가 기아상태`에 빠질수 있음
2. 대기할때 자원을 점유하고 있지 않아야 함
      - 새로운 자원을 요구할때 할당받았던 `자원을 모두 해제`
   - 점유 도중 해제할 수 없는 자원에는 `적용 불가`



### 비선점 조건 제거(No Preemmption)
- 선점이 가능하도록 해야함
  - CPU , memory에 적용 가능
  - 자원의 특성에 따라 불가능한 경우 존재(프린터)
- 다른 프로세스가 대기할 가능성 줄이기
  - 점유대기 상황이 발생하면 할당받았던 자원을 모두 해체
  - 프린터같은 자원에는 `적용 불가`

### 환형대기 조건 제거
- 모든 자원에 일련번호를 지정
  - 함수 f:R -> N (R:자원집합, N:자연수 집합)
  - ri != rj 이면 f(ri) !=f(rj)
- 프로세스마다 요구순서가 다를수 있으므로 일련번호 설정이 어렵다
- 일련번호 기준을 만족하지 못하면 자원을 해제해야 하는데, 프린터와 같이 `적용불가`한 자원들이 존재한다.
#### 방법 1. 프로세스는 자원을 요구할때 일련번호 기준으로 항상 오름차순이 되도록 요구
- 가장 최근에 할당받은 자원이 ri면 다음에 요구할 자원 rj는 f(ri)<f(rj) 만족
#### 방법 2. 프로세스가 자원을 요구할때 그보다 작은 일련번호가 작은 자원만 점유하도록 함
- 자원rj 요구하려면 점유자원 중 f(rj)≤f(rj)인 자원 ri 는 모두 해제


## 교착상태 회피(Deadlock Avoidance)
- 프로세스의 자원 사용에 대한 `사전 정보`를 활용하여, 교착상태가 발생하지 않는 상태에 머물도록 하는 방법
- 사전정보
  - 현재 할당된 자원의 정보
  - 현재 가용상태의 자원
  - 프로세스들의 최대 요구량
### 안전상태
- 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량 까지 빠짐없이 자원을 할당할 수 있는 상태
- 안전 순서열이 존재하는 경우
- `교착 상태`가 발생하지 않는 상태
### 불안전 상태
- 안전순 서열이 존재하지 않는 경우
- `교착 상태`가 발생할 수 있는 상태
  - `교착 상태`는 `불안전 상태`의 부분집합이다.
  
### 안전순서열
- 순서 있는 프로세스의 집합<p1,p2... ,pn>
- 각 pi에 대해 pi가 추가로 요구할 수 있는 자원의 양이 현재 가용상태의 자원으로 충당되거나 혹은 여기에 pj(단, j< i )에 할당된 자원까지 포함하여 중당 가능한 경우



| 프로세스 | 최대 요구량 |  현재 할당량 |추가 요구량|
| :----:  | :----: |  :----: | :---: |
| P1 | 5 |  0 |5|
| P2 | 2 |  0 |2|
| P3 | 8 |  0 |8|

총단위 자원수 :8개, 가용 단위자원수 : 8

#### 안전상태의 예
```
총단위 자원수 :8개, 가용 단위자원수 : 2
```

| 프로세스 | 최대 요구량 |  현재 할당량 |추가 요구량|
| :----:  | :----: |  :----: | :---: |
| P1 | 5 |  0 |5|
| P2 | 2 |  1 |1|
| P3 | 8 |  5 |3|

- 안전 순서열: `<P2,P3,P1>`(가상으로 자원을 할당)
1. P2 프로세스가 추가 요구량 1개를 할당받으면, p2는 자신의 최대 요구량을 할당 받았으므로 종료가 가능해진다.
2. P2가 종료되면 2개의 단위자원이 해제되어 가용자원이 3개가 된다.
3. P3 프로세스가 추가 요구량 3개를 할당 받으면, p3는 자신의 최대 요구량을 할당 받았으므로 종료가 가능해진다.
4. P3가 종료되면 8개의 단위자원이 해제되어 가용자원이 8개가 된다.
5. P1 프로세스가 추가요구량 5개를 할당받아 종료가 가능해진다.


#### 불안전 상태의 예
```
총단위 자원수 :8개, 가용 단위자원수 : 1
```
| 프로세스 | 최대 요구량 |  현재 할당량 |추가 요구량|
| :----:  | :----: |  :----: | :---: |
| P1 | 5 |  1 |4|
| P2 | 2 |  1 |1|
| P3 | 8 |  5 |3|

- 프로세스 P2가 자원을 하나 할당 받아 종료된다고 하더라도, 반환되는 자원수는 2개 뿐이다.
- 프로세스 P1, P2는 각각 4개와 3개의 자원을 요구하므로 어느 프로세스도 종료될 수 없다.(교착상태)
- 교착상태가 발생할 수 있는 불안전 상태이다.





## 교착상태의 회피
- 교착상태는 불안전 상태에서만 발생 가능
- 항상 안전상태를 유지해야 함
- 프로세스가 가용상태의 자원을 요구하더라도 프로세스는 대기상태 가 될수 있음(불안전 상태의 회피)
  - 자원이용률은 다소 낮아질 수 있다.
## 교착상태 회피 알고리즘
- 각 자원의 단위자원이 하나밖에 없는 경우
  - 변형된 자원할당 그래프 이용
- 각 자원의 단위자원이 여러개 일수 잇는 경우
  - 은행원 알고리즘 이용
### Case 1. 각 자원의 단위자원이 하나밖에 없는 경우
- 변형된 자원할당 그래프
- 자원 정점에 표시하던 단위자원의 개수 제거
- 선언간선(pi,rj) 추가
  - 미래에 프로세스 Pi가 자원 Rj를 요구할수 있는 상황을 간선으로 나타냄
  - 요구간선과 구분을 위해 점선으로 표시
- 자원을 요구받으면 선언간선을 요구간선으로  변경
- 요구간선을 할당간선으로 변환해도 `사이클이 생기지 않는 경우`에만 자원을 할당하고 할당간선으로 변환(사이클이 생길 가능성을 체크)

![alt text](/Computer%20Science/운영체제/이미지/불안전상태자원할당그래프.png)

### Case 2. 각 자원의 단위자원이 여러 개일 수 있는 경우
### 은행원 알고리즘(Banker's Alorithm)
- 프로세스가 자원을 요청하면 자원 할당시 deadlock으로부터 안전한지 동적으로 조사하여 안전한 경우에만 할당한다.(safe sate 여부 확인)
- safe state : 시스템 내의 프로세스에 대한 safe sequence가 존재하는 상태
- 안전상태가 보장되는 경우에만 자원을 할당
1. MAXi
2. ALLOC
3. NEED
4. AVAIL
5. REQ
6. WORK 

#### 예시
- 3개의 프로세스 P1,P2,P3
- 3개의 자원 A(10) B(5) C(7)가 있을때

|Available|
| :----:  |
|ABC|
|3,3,2|

| 프로세스 | Allocation |  Max |Need(Max-Allocation)|
| :----:  | :----: |   :---: |:---: |
| P1 | 0,1,0 |  7,5,3 |7,4,2
| P2 | 2,0,0 |  3,2,2 |1,2,2
| P3 | 3,0,0 |  9,0,2 |6,0,0

- P2 P3 P1순으로 필요한 자원(Need)를 할당하면 교착상태가 발생하지 않고, 모든 프로세스가 작업을 수행하고 종료될 수 있다.
- 즉 sequence<P2,P3,P1>는 safe state 이다.


안전 알고리즘

## 교착상태 탐지 및 복구(Deadlock Detection and Recovery)
- 교착상태 발생 사후에 처리하는 방법
### 교착상태 탐지
- 시스템의 교착상태 여부를 조사하기 위해 주기적으로 상태조사 알고리즘을 수행
- 교착상태 회피와 다르게 최악의 경우를 따지지 않고 현재의 상태에만 중점을 둔다.


### Shoshani와 Coffman 알고리즘


| 프로세스 | ALLOCi |  REQi |추가 요구량|
| :----:  | :----: |  :----: | :---: |
| P1 | 5 |  0 |5|
| P2 | 2 |  1 |1|
| P3 | 8 |  5 |3|

- 할당받은게 없으면 FINISH를 true 둔다.
- 가용 가능한 자원량이 현재 요구량을 충족시켜 줄 수 있다면 FINISH를 true 둔다.
- 최종적으로 FINISH가 false인 프로세스가 존재한다면 교착상태로 판단한다.
- 시간복잡도 O(mn^2), 시간이 오래걸린다.
- 알고리즘의 수행 시점
  - 즉시 받아들일 수 없는 자원요구가 있을 때
  - 정해진 시간 간격
  - CPU 효율이 일정수준 이하로 떨어질 때

## 교착상태 복구
- 교착상태가 탐지된 경우 적절한 조치를 취해 정상상태로 복구
- 복구의 주체
  - 오퍼레이터 : 수작업으로 복구
  - 운영체제 :자동으로 복구
- 복구방법
### 교착상태 프로세스를 종료(Process termination)
#### 1. 모든 교착상태 프로세스를 종료
- 장점 : 교착상태가 확실히 해소된다.
- 단 점: 진행했던 내용에 대한 복원비용이 큼
#### 2. 사이클이 제거될때까지 교착상태 프로세스를 하나씩 종료
- 단점: 종료 대상을 선택하기 위한 비용 매 프로세스 종료 후 교착상태 재확인을 위한 비용(오버헤드) 발생
### 교착상태 프로세스가 할당받은 자원을 해제(Resource Preemption)
- 사이클이 제거될때 까지 할당된 자원을 단계적으로 선점하여 다른 프로세스들에 할당
- 프로세스와 자원 선택 기준
  - 프로세스 진척도, 사용중인 자원의 수 등
  - 프로세스의 복귀 시점도 제반 요소를 고려하여 결정
  - 기아상태에 빠지지 않도록 프로세스 선택시 복구 횟수 고려

## Deadlock Ignorance
- deadlock이 일어나지 않는다고 가정하고 아무런 조치도 취하지 않는다
- deadlock은 드물게 발생하므로 조치 자체가 오버헤드가 된다.
- deadlock 발생시 사용자가 시스템의 비정상적 작동을 감지하여 process를 죽이는 등 방법으로 대처한다
- UNIX Windows 등 범용 OS가 이방법을 채택한다.
